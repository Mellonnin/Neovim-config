==============================================================================
1. Insert mode						*insert-index*
------------------------------------------------------------------------------  
CTRL-@		insert previously inserted text and stop insert
CTRL-A		insert previously inserted text
CTRL-O		execute a single command and return to insert mode
CTRL-T		insert one shiftwidth of indent in current line
CTRL-U		delete all entered characters in the current line
CTRL-W		delete word before the cursor
==============================================================================
CTRL-B		1             scroll N screens Backwards
CTRL-C		              interrupt current (search) command
CTRL-G		              display current file name and position
CTRL-L		              redraw screen
<CR>		  1             cursor to the first CHAR N lines lower
U		      2             redo changes which were undone with 'u'
CTRL-V		              start blockwise Visual mode
CTRL-Y		              scroll N lines downwards
CTRL-Z		              suspend program (or start new shell)
CTRL-^		              edit Nth alternate file (equivalent to ":e #N")
!{motion}{filter} 2     filter Nmove text through the {filter} command
!!{filter}	2           filter N lines through the {filter} command
#		1                   search backward for the Nth occurrence of the ident under the cursor
$		1                   cursor to the end of Nth next line
'{a-zA-Z0-9}	1         cursor to the first CHAR on the line with mark {a-zA-Z0-9}
'(		1                 cursor to the first CHAR on the line of the start of the current sentence
')		1                 cursor to the first CHAR on the line of the end of the current sentence
'<		1                 cursor to the first CHAR of the line where highlighted area starts/started in the current buffer.
'>		1                 cursor to the first CHAR of the line where highlighted area ends/ended in the current buffer.
'[		1                 cursor to the first CHAR on the line of the start of last operated text or start of put text
']		1                 cursor to the first CHAR on the line of the end of last operated text or end of put text
'{		1                 cursor to the first CHAR on the line of the start of the current paragraph
'}		1                 cursor to the first CHAR on the line of the end of the current paragraph
(		1                   cursor N sentences backward
)		1                   cursor N sentences forward
*		1                   search forward for the Nth occurrence of the ident under the cursor
,		1                   repeat latest f, t, F or T in opposite direction N times
-		1                   cursor to the first CHAR N lines higher
.		2                   repeat last change with count replaced with N
/{pattern}<CR>	1       search forward for the Nth occurrence of {pattern}
/<CR>		1               search forward for {pattern} of last search
0		1                   cursor to the first char of the line
{count}:	              start entering an Ex command with range from current line to N-1 lines down
;		1                   repeat latest f, t, F or T N times
<{motion}	2             shift Nmove lines one 'shiftwidth' leftwards
<<		2                 shift N lines one 'shiftwidth' leftwards
={motion}	2             filter Nmove lines through "indent"
==		2                 filter N lines through "indent"
>{motion}	2             shift Nmove lines one 'shiftwidth' rightwards
>>		2                 shift N lines one 'shiftwidth' rightwards
?{pattern}<CR>	1       search backward for the Nth previous occurrence of {pattern}
R>|		?<CR>		1         search backward for {pattern} of last search
@{a-z}		2             execute the contents of register {a-z} N times
@:		                  repeat the previous ":" command N times
@@		2                 repeat the previous @{a-z} N times
A		2                   append text after the end of the line N times
B		1                   cursor N WORDS backward
["x]C		2               change from the cursor position to the end of the line, and N-1 more lines [into register x]; synonym for "c$"
["x]D		2               delete the characters under the cursor until the end of the line and N-1 more lines [into register x]; synonym for "d$"
E		1                   cursor forward to the end of WORD N
F{char}		1             cursor to the Nth occurrence of {char} to the left
G		1                   cursor to line N, default last line
H		1                   cursor to line N from top of screen
I		2                   insert text before the first CHAR on the line N times
L		1                   cursor to line N from bottom of screen
M		1                   cursor to middle line of screen
N		1                   repeat the latest '/' or '?' N times in opposite direction
O		2                   begin a new line above the cursor and insert text, repeat N times
["x]P		2               put the text [from register x] before the cursor N times
R		2                   enter replace mode: overtype existing characters, repeat the entered text N-1 times
["x]S		2               delete N lines [into register x] and start insert; synonym for "cc".
T{char}		1             cursor till after Nth occurrence of {char} to the left
V		                    start linewise Visual mode
W		1                   cursor N WORDS forward
["x]X		2               delete N characters before the cursor [into register x]
["x]Y		                yank N lines [into register x]; synonym for "yy" Note: Mapped to "y$" by default.
^		1                   cursor to the first CHAR of the line
_		1                   cursor to the first CHAR N - 1 lines lower
`{a-zA-Z0-9}	1         cursor to the mark {a-zA-Z0-9}
`(		1                 cursor to the start of the current sentence
`)		1                 cursor to the end of the current sentence
`<		1                 cursor to the start of the highlighted area
`>		1                 cursor to the end of the highlighted area
`[		1                 cursor to the start of last operated text or start of putted text
`]		1                 cursor to the end of last operated text or end of putted text
`{		1                 cursor to the start of the current paragraph
`}		1                 cursor to the end of the current paragraph
a		2                   append text after the cursor N times
b		1                   cursor N words backward
["x]c{motion}	2         delete Nmove text [into register x] and start insert
["x]cc		2             delete N lines [into register x] and start insert
e		1                   cursor forward to the end of word N
f{char}		1             cursor to Nth occurrence of {char} to the right
g{char}		              extended commands, see |g| below
h		1                   cursor N chars to the left
i		2                   insert text before the cursor N times
j		1                   cursor N lines downward
k		1                   cursor N lines upward
l		1                   cursor N chars to the right
n		1                   repeat the latest '/' or '?' N times
o		2                   begin a new line below the cursor and insert text, repeat N times
["x]p		2               put the text [from register x] after the cursor N times
r{char}		2             replace N chars with {char}
["x]s		2               (substitute) delete N characters [into register x] and start insert
t{char}		1             cursor till before Nth occurrence of {char} to the right
u		2                   undo changes
v		                    start charwise Visual mode
w		1                   cursor N words forward
["x]x		2               delete N characters under and after the cursor [into register x]
["x]y{motion}	          yank Nmove text [into register x]
["x]yy		              yank N lines [into register x]
z{char}		              commands starting with 'z', see |z| below
{		1                   cursor N paragraphs backward
|		|		1               cursor to column N
}		1                   cursor N paragraphs forward
~		2                   'tildeop' off: switch case of N characters under cursor and move the cursor N characters to the right
==============================================================================
[ CTRL-I	    jump to first line in current and included files that contains the word under the cursor, start searching at beginning of current file
[#		1       cursor to N previous unmatched #if, #else or #ifdef
['		1       cursor to previous lowercase mark, on first non-blank
[(		1       cursor N times back to unmatched '('
[`		1       cursor to previous lowercase mark
[/		1       cursor to N previous start of a C comment
[D		        list all defines found in current and included files matching the word under the cursor, start searching at beginning of current file
[I		        list all lines found in current and included files that contain the word under the cursor, start searching at beginning of current file
[[		1       cursor N sections backward
[]		1       cursor N SECTIONS backward
[c		1       cursor N times backwards to start of change
[i		        show first line found in current and included files that contains the word under the cursor, start searching at beginning of current file
[m		1       cursor N times back to start of member function
[p		2       like "P", but adjust indent to current line
[s		1       move to the previous misspelled word
[z		1       move to start of open fold
[{		1       cursor N times back to unmatched '{'
CTRL-I	      jump to first line in current and included files that contains the word under the cursor, start searching at cursor position
]#		1       cursor to N next unmatched #endif or #else
]'		1       cursor to next lowercase mark, on first non-blank
])		1       cursor N times forward to unmatched ')'
]`		1       cursor to next lowercase mark
]/		1       cursor to N next end of a C comment
]D		        list all #defines found in current and included files matching the word under the cursor, start searching at cursor position
]I		        list all lines found in current and included files that contain the word under the cursor, start searching at cursor position
][		1       cursor N SECTIONS forward
]]		1       cursor N sections forward
]c		1       cursor N times forward to start of change
]i		        show first line found in current and included files that contains the word under the cursor, start searching at cursor position
]m		1       cursor N times forward to end of member function
]p		2       like "p", but adjust indent to current line
]s		1       move to next misspelled word
]z		1       move to end of open fold
]}		1       cursor N times forward to unmatched '}'
==============================================================================
2.4 Commands starting with 'g'						*g*

tag		char	      note action in Normal mode	 
------------------------------------------------------------------------------  
g#		1           like "#", but without using "\<" and "\>"
g$		1           when 'wrap' off go to rightmost character of the current line that is on the screen; 
g&		2           repeat last ":s" on all lines
g*		1           like "*", but without using "\<" and "\>"
g+		            go to newer text state N times
g,		1           go to N newer position in change list
g-		            go to older text state N times
g0		1           when 'wrap' off go to leftmost character of the current line that is on the screen;
g;		1           go to N older position in change list
g<		            display previous command output
gE		1           go backwards to the end of the previous WORD
gI		2           like "I", but always start in column 1
gJ		2           join lines without inserting space
gN	  1,2         find the previous match with the last used search pattern and Visually select it
["x]gP	2         put the text [from register x] before the cursor N times, leave the cursor after it
gR		2           enter Virtual Replace mode
gU{motion}	2     make Nmove text uppercase
g]		            :tselect on the tag under the cursor
g^		1           when 'wrap' off go to leftmost non-white character of the current line that is on the screen; 
g_		1           cursor to the last CHAR N - 1 lines lower
ge		1           go backwards to the end of the previous word
gg		1           cursor to line N, default first line
gi		2           like "i", but first move to the |'^| mark
gm		1           go to character at middle of the screenline
gM		1           go to character at middle of the text line
gn	  1,2         find the next match with the last used search pattern and Visually select it
go		1           cursor to byte N in the buffer
["x]gp		2       put the text [from register x] after the cursor N times, leave the cursor after it
gv		            reselect the previous Visual area
gx		            execute application for file name under the cursor (only with |netrw| plugin)
g~{motion}	2     swap case for Nmove text
==============================================================================
2.5 Commands starting with 'z'						*z*

tag		char	      note action in Normal mode	 
------------------------------------------------------------------------------  
z<CR>		          redraw, cursor line to top of window, cursor on first non-blank
z{height}<CR>	    redraw, make window {height} lines high
z+		            cursor on line N (default line below window), otherwise like "z<CR>"
z-		            redraw, cursor line at bottom of window, cursor on first non-blank
z.		            redraw, cursor line to center of window, cursor on first non-blank
z=		            give spelling suggestions
zA		            open a closed fold or close an open fold recursively
zC		            close folds recursively
zD		            delete folds recursively
zE		            eliminate all folds
zF		            create a fold for N lines
zG		            temporarily mark word as correctly spelled
zH		            when 'wrap' off scroll half a screenwidth to the right
zL		            when 'wrap' off scroll half a screenwidth to the left
zM		            set 'foldlevel' to zero
zN		            set 'foldenable'
zO		            open folds recursively
zR		            set 'foldlevel' to the deepest fold
zW		            temporarily mark word as incorrectly spelled
zX		            re-apply 'foldlevel'
z^		            cursor on line N (default line above window), otherwise like "z-"
za		            open a closed fold, close an open fold
zb		            redraw, cursor line at bottom of window
zc		            close a fold
zd		            delete a fold
ze		            when 'wrap' off scroll horizontally to position the cursor at the end (right side) of the screen
zf{motion}	      create a fold for Nmove text
zg		            permanently mark word as correctly spelled
zh		            when 'wrap' off scroll screen N characters to the right
zi		            toggle 'foldenable'
zj		1           move to the start of the next fold
zk		1           move to the end of the previous fold
zl		            when 'wrap' off scroll screen N characters to the left
zm		            subtract one from 'foldlevel'
zn		            reset 'foldenable'
zo		            open fold
zp		            paste in block-mode without trailing spaces
zP		            paste in block-mode without trailing spaces
zr		            add one to 'foldlevel'
zs		            when 'wrap' off scroll horizontally to position the cursor at the start (left side) of the screen
zt		            redraw, cursor line at top of window
zuw		            undo |zw|
zug		            undo |zg|
zuW		            undo |zW|
zuG		            undo |zG|
zv		            open enough folds to view the cursor line
zw		            permanently mark word as incorrectly spelled
zx		            re-apply 'foldlevel' and do "zv"
zy		            yank without trailing spaces
zz		            redraw, cursor line at center of window
==============================================================================
3. Visual mode						*visual-index*

Most commands in Visual mode are the same as in Normal mode.  The ones listed
here are those that are different.

tag		command	      note action in Visual mode	 
------------------------------------------------------------------------------  
CTRL-C		    stop Visual mode
CTRL-V		    make Visual mode blockwise or stop Visual mode
CTRL-X		2   subtract N from number in highlighted text
<Esc>		      stop Visual mode
CTRL-]		    jump to highlighted tag
!{filter}	2   filter the highlighted lines through the external command {filter}
:		          start a command-line with the highlighted lines as a range
<		2         shift the highlighted lines one 'shiftwidth' left
=		2         filter the highlighted lines through the external program given with the 'equalprg' option
>		2         shift the highlighted lines one 'shiftwidth' right
A		2         block mode: append same text in all lines, after the highlighted area
C		2         delete the highlighted lines and start insert
D		2         delete the highlighted lines
I		2         block mode: insert same text in all lines, before the highlighted area
J		2         join the highlighted lines
O		          move horizontally to other corner of area
P		          replace highlighted area with register contents; registers are unchanged
R		2         delete the highlighted lines and start insert
S		2         delete the highlighted lines and start insert
U		2         make highlighted area uppercase
V		          make Visual mode linewise or stop Visual mode
X		2         delete the highlighted lines
Y		          yank the highlighted lines
c		2         delete highlighted area and start insert
d		2         delete highlighted area
gJ		2       join the highlighted lines without inserting spaces
gv		        exchange current and previous highlighted area
o		          move cursor to other corner of area
p		          replace highlighted area with register contents; deleted text in unnamed register
r		2         replace highlighted area with a character
u		2         make highlighted area lowercase
v		          make Visual mode charwise or stop Visual mode
x		      2   delete the highlighted area








|:range|	:{range}	go to last line in {range}
|:!|		:!		filter lines or execute an external command
|:!!|		:!!		repeat last ":!" command
|:#|		:#		same as ":number"
|:&|		:&		repeat last ":substitute"
|:star|		:*		use the last Visual area, like :'<,'>
|:<|		:<		shift lines one 'shiftwidth' left
|:=|		:=		print the last line number
|:>|		:>		shift lines one 'shiftwidth' right
|:@|		:@		execute contents of a register
|:@@|		:@@		repeat the previous ":@"
|:Next|		:N[ext]		go to previous file in the argument list
|:append|	:a[ppend]	append text
|:abbreviate|	:ab[breviate]	enter abbreviation
|:abclear|	:abc[lear]	remove all abbreviations
|:aboveleft|	:abo[veleft]	make split window appear left or above
|:all|		:al[l]		open a window for each file in the argument list
|:amenu|	:am[enu]	enter new menu item for all modes
|:anoremenu|	:an[oremenu]	enter a new menu for all modes that will not be remapped
|:args|		:ar[gs]		print the argument list
|:argadd|	:arga[dd]	add items to the argument list
|:argdedupe|	:argded[upe]	remove duplicates from the argument list
|:argdelete|	:argd[elete]	delete items from the argument list
|:argedit|	:arge[dit]	add item to the argument list and edit it
|:argdo|	:argdo		do a command on all items in the argument list
|:argglobal|	:argg[lobal]	define the global argument list
|:arglocal|	:argl[ocal]	define a local argument list
|:argument|	:argu[ment]	go to specific file in the argument list
|:ascii|	:as[cii]	print ascii value of character under the cursor
|:autocmd|	:au[tocmd]	enter or show autocommands
|:augroup|	:aug[roup]	select the autocommand group to use
|:aunmenu|	:aun[menu]	remove menu for all modes
|:belowright|	:bel[owright]	make split window appear right or below
|:bfirst|	:bf[irst]	go to first buffer in the buffer list
|:blast|	:bl[ast]	go to last buffer in the buffer list
|:bmodified|	:bm[odified]	go to next buffer in the buffer list that has been modified
|:bnext|	:bn[ext]	go to next buffer in the buffer list
|:botright|	:bo[tright]	make split window appear at bottom or far right
|:bprevious|	:bp[revious]	go to previous buffer in the buffer list
|:brewind|	:br[ewind]	go to first buffer in the buffer list
|:break|	:brea[k]	break out of while loop
|:breakadd|	:breaka[dd]	add a debugger breakpoint
|:breakdel|	:breakd[el]	delete a debugger breakpoint
|:breaklist|	:breakl[ist]	list debugger breakpoints
|:browse|	:bro[wse]	use file selection dialog
|:bufdo|	:bufdo		execute command in each listed buffer
|:buffers|	:buffers	list all files in the buffer list
|:bunload|	:bun[load]	unload a specific buffer
|:bwipeout|	:bw[ipeout]	really delete a buffer
|:change|	:c[hange]	replace a line or series of lines
|:cNext|	:cN[ext]	go to previous error
|:cNfile|	:cNf[ile]	go to last error in previous file
|:cabbrev|	:ca[bbrev]	like ":abbreviate" but for Command-line mode
|:cabclear|	:cabc[lear]	clear all abbreviations for Command-line mode
|:cabove|	:cabo[ve]	go to error above current line
|:caddbuffer|	:cad[dbuffer]	add errors from buffer
|:caddexpr|	:cadde[xpr]	add errors from expr
|:caddfile|	:caddf[ile]	add error message to current quickfix list
|:cafter|	:caf[ter]	go to error after current cursor
|:call|		:cal[l]		call a function
|:catch|	:cat[ch]	part of a :try command
|:cbefore|	:cbef[ore]	go to error before current cursor
|:cbelow|	:cbel[ow]	go to error below current line
|:cbottom|	:cbo[ttom]	scroll to the bottom of the quickfix window
|:cbuffer|	:cb[uffer]	parse error messages and jump to first error
|:cclose|	:ccl[ose]	close quickfix window
|:cd|		:cd		change directory
|:cdo|		:cdo		execute command in each valid error list entry
|:cfdo|		:cfd[o]		execute command in each file in error list
|:cexpr|	:cex[pr]	read errors from expr and jump to first
|:cfile|	:cf[ile]	read file with error messages and jump to first
|:cfirst|	:cfir[st]	go to the specified error, default first one
|:cgetbuffer|	:cgetb[uffer]	get errors from buffer
|:cgetexpr|	:cgete[xpr]	get errors from expr
|:cgetfile|	:cg[etfile]	read file with error messages
|:changes|	:changes	print the change list
|:chdir|	:chd[ir]	change directory
|:checkhealth|	:che[ckhealth]	run healthchecks
|:checkpath|	:checkp[ath]	list included files
|:checktime|	:checkt[ime]	check timestamp of loaded buffers
|:chistory|	:chi[story]	list the error lists
|:clast|	:cla[st]	go to the specified error, default last one
|:clist|	:cl[ist]	list all errors
|:close|	:clo[se]	close current window
|:cmap|		:cm[ap]		like ":map" but for Command-line mode
|:cmapclear|	:cmapc[lear]	clear all mappings for Command-line mode
|:cmenu|	:cme[nu]	add menu for Command-line mode
|:cnext|	:cn[ext]	go to next error
|:cnewer|	:cnew[er]	go to newer error list
|:cnfile|	:cnf[ile]	go to first error in next file
|:cnoremap|	:cno[remap]	like ":noremap" but for Command-line mode
|:cnoreabbrev|	:cnorea[bbrev]	like ":noreabbrev" but for Command-line mode
|:cnoremenu|	:cnoreme[nu]	like ":noremenu" but for Command-line mode
|:copy|		:co[py]		copy lines
|:colder|	:col[der]	go to older error list
|:colorscheme|	:colo[rscheme]	load a specific color scheme
|:command|	:com[mand]	create user-defined command
|:comclear|	:comc[lear]	clear all user-defined commands
|:compiler|	:comp[iler]	do settings for a specific compiler
|:continue|	:con[tinue]	go back to :while
|:confirm|	:conf[irm]	prompt user when confirmation required
|:const|	:cons[t]	create a variable as a constant
|:copen|	:cope[n]	open quickfix window
|:cprevious|	:cp[revious]	go to previous error
|:cpfile|	:cpf[ile]	go to last error in previous file
|:cquit|	:cq[uit]	quit Vim with an error code
|:crewind|	:cr[ewind]	go to the specified error, default first one
|:cunmap|	:cu[nmap]	like ":unmap" but for Command-line mode
|:cunabbrev|	:cuna[bbrev]	like ":unabbrev" but for Command-line mode
|:cunmenu|	:cunme[nu]	remove menu for Command-line mode
|:cwindow|	:cw[indow]	open or close quickfix window
|:delete|	:d[elete]	delete lines
|:debug|	:deb[ug]	run a command in debugging mode
|:debuggreedy|	:debugg[reedy]	read debug mode commands from normal input
|:delcommand|	:delc[ommand]	delete user-defined command
|:delfunction|	:delf[unction]	delete a user function
|:delmarks|	:delm[arks]	delete marks
|:diffupdate|	:dif[fupdate]	update 'diff' buffers
|:diffget|	:diffg[et]	remove differences in current buffer
|:diffoff|	:diffo[ff]	switch off diff mode
|:diffpatch|	:diffp[atch]	apply a patch and show differences
|:diffput|	:diffpu[t]	remove differences in other buffer
|:diffsplit|	:diffs[plit]	show differences with another file
|:diffthis|	:diffthis	make current window a diff window
|:digraphs|	:dig[raphs]	show or enter digraphs
|:display|	:di[splay]	display registers
|:dl|		:dl		short for |:delete| with the 'l' flag
|:dp|		:d[elete]p	short for |:delete| with the 'p' flag
|:drop|		:dr[op]		jump to window editing file or edit file in current window
|:dsearch|	:ds[earch]	list one #define
|:edit|		:e[dit]		edit a file
|:earlier|	:ea[rlier]	go to older change, undo
|:echo|		:ec[ho]		echoes the result of expressions
|:echoerr|	:echoe[rr]	like :echo, show like an error and use history
|:echohl|	:echoh[l]	set highlighting for echo commands
|:echomsg|	:echom[sg]	same as :echo, put message in history
|:echon|	:echon		same as :echo, but without <EOL>>>
|:emenu|	:em[enu]	execute a menu by name
|:endfunction|	:endf[unction]	end of a user function started with :function
|:endtry|	:endt[ry]	end previous :try
|:endwhile|	:endw[hile]	end previous :while
|:enew|		:ene[w]		edit a new, unnamed buffer
|:eval|		:ev[al]		evaluate an expression and discard the result
|:ex|		:ex		same as ":edit"
|:execute|	:exe[cute]	execute result of expressions
|:exit|		:exi[t]		same as ":xit"
|:exusage|	:exu[sage]	overview of Ex commands
|:file|		:f[ile]		show or set the current file name
|:files|	:files		list all files in the buffer list
|:filetype|	:filet[ype]	switch file type detection on/off
|:filter|	:filt[er]	filter output of following command
|:find|		:fin[d]		find file in 'path' and edit it
|:finally|	:fina[lly]	part of a :try command
|:finish|	:fini[sh]	quit sourcing a Vim script
|:first|	:fir[st]	go to the first file in the argument list
|:fold|		:fo[ld]		create a fold
|:foldclose|	:foldc[lose]	close folds
|:folddoopen|	:foldd[oopen]	execute command on lines not in a closed fold
|:folddoclosed|	:folddoc[losed]	execute command on lines in a closed fold
|:foldopen|	:foldo[pen]	open folds
|:for|		:for		for loop
|:function|	:fu[nction]	define a user function
|:global|	:g[lobal]	execute commands for matching lines
|:goto|		:go[to]		go to byte in the buffer
|:grep|		:gr[ep]		run 'grepprg' and jump to first match
|:grepadd|	:grepa[dd]	like :grep, but append to current list
|:gui|		:gu[i]		start the GUI
|:gvim|		:gv[im]		start the GUI
|:help|		:h[elp]		open a help window
|:helpclose|	:helpc[lose]	close one help window
|:helpgrep|	:helpg[rep]	like ":grep" but searches help files
|:helptags|	:helpt[ags]	generate help tags for a directory
|:highlight|	:hi[ghlight]	specify highlighting methods
|:hide|		:hid[e]		hide current buffer for a command
|:history|	:his[tory]	print a history list
|:horizontal|	:hor[izontal]	following window command work horizontally
|:insert|	:i[nsert]	insert text
|:iabbrev|	:ia[bbrev]	like ":abbrev" but for Insert mode
|:iabclear|	:iabc[lear]	like ":abclear" but for Insert mode
|:if|		:if		execute commands when condition met
|:ijump|	:ij[ump]	jump to definition of identifier
|:ilist|	:il[ist]	list lines where identifier matches
|:imap|		:im[ap]		like ":map" but for Insert mode
|:imapclear|	:imapc[lear]	like ":mapclear" but for Insert mode
|:imenu|	:ime[nu]	add menu for Insert mode
|:inoremap|	:ino[remap]	like ":noremap" but for Insert mode
|:inoreabbrev|	:inorea[bbrev]	like ":noreabbrev" but for Insert mode
|:inoremenu|	:inoreme[nu]	like ":noremenu" but for Insert mode
|:intro|	:int[ro]	print the introductory message
|:isearch|	:is[earch]	list one line where identifier matches
|:isplit|	:isp[lit]	split window and jump to definition of identifier
|:iunmap|	:iu[nmap]	like ":unmap" but for Insert mode
|:iunabbrev|	:iuna[bbrev]	like ":unabbrev" but for Insert mode
|:iunmenu|	:iunme[nu]	remove menu for Insert mode
|:join|		:j[oin]		join lines
|:keepalt|	:keepa[lt]	following command keeps the alternate file
|:keepmarks|	:kee[pmarks]	following command keeps marks where they are
|:keeppatterns|	:keepp[atterns]	following command keeps search pattern history
|:lNext|	:lN[ext]	go to previous entry in location list
|:lNfile|	:lNf[ile]	go to last entry in previous file
|:list|		:l[ist]		print lines
|:labove|	:lab[ove]	go to location above current line
|:laddexpr|	:lad[dexpr]	add locations from expr
|:laddbuffer|	:laddb[uffer]	add locations from buffer
|:laddfile|	:laddf[ile]	add locations to current location list
|:lafter|	:laf[ter]	go to location after current cursor
|:last|		:la[st]		go to the last file in the argument list
|:later|	:lat[er]	go to newer change, redo
|:lbefore|	:lbef[ore]	go to location before current cursor
|:lbelow|	:lbel[ow]	go to location below current line
|:lbottom|	:lbo[ttom]	scroll to the bottom of the location window
|:lbuffer|	:lb[uffer]	parse locations and jump to first location
|:lcd|		:lc[d]		change directory locally
|:lchdir|	:lch[dir]	change directory locally
|:lclose|	:lcl[ose]	close location window
|:ldo|		:ld[o]		execute command in valid location list entries
|:lfdo|		:lfd[o]		execute command in each file in location list
|:left|		:le[ft]		left align lines
|:let|		:let		assign a value to a variable or option
|:lexpr|	:lex[pr]	read locations from expr and jump to first
|:lfile|	:lf[ile]	read file with locations and jump to first
|:lfirst|	:lfir[st]	go to the specified location, default first one
|:lgetbuffer|	:lgetb[uffer]	get locations from buffer
|:lgetexpr|	:lgete[xpr]	get locations from expr
|:lgetfile|	:lg[etfile]	read file with locations
|:lgrep|	:lgr[ep]	run 'grepprg' and jump to first match
|:lgrepadd|	:lgrepa[dd]	like :grep, but append to current list
|:lhelpgrep|	:lh[elpgrep]	like ":helpgrep" but uses location list
|:lhistory|	:lhi[story]	list the location lists
|:ll|		:ll		go to specific location
|:llast|	:lla[st]	go to the specified location, default last one
|:llist|	:lli[st]	list all locations
|:lmake|	:lmak[e]	execute external command 'makeprg' and parse error messages
|:lmap|		:lm[ap]		like ":map!" but includes Lang-Arg mode
|:lmapclear|	:lmapc[lear]	like ":mapclear!" but includes Lang-Arg mode
|:lnext|	:lne[xt]	go to next location
|:lnewer|	:lnew[er]	go to newer location list
|:lnfile|	:lnf[ile]	go to first location in next file
|:lnoremap|	:ln[oremap]	like ":noremap!" but includes Lang-Arg mode
|:loadkeymap|	:loadk[eymap]	load the following keymaps until EOF
|:loadview|	:lo[adview]	load view for current window from a file
|:lockmarks|	:loc[kmarks]	following command keeps marks where they are
|:lockvar|	:lockv[ar]	lock variables
|:lolder|	:lol[der]	go to older location list
|:lopen|	:lope[n]	open location window
|:lprevious|	:lp[revious]	go to previous location
|:lpfile|	:lpf[ile]	go to last location in previous file
|:lrewind|	:lr[ewind]	go to the specified location, default first one
|:ls|		:ls		list all buffers
|:ltag|		:lt[ag]		jump to tag and add matching tags to the location list
|:lunmap|	:lu[nmap]	like ":unmap!" but includes Lang-Arg mode
|:lua|		:lua		execute |Lua| command
|:luado|	:luad[o]	execute Lua command for each line
|:luafile|	:luaf[ile]	execute |Lua| script file
|:lvimgrep|	:lv[imgrep]	search for pattern in files
|:lvimgrepadd|	:lvimgrepa[dd]	like :vimgrep, but append to current list
|:lwindow|	:lw[indow]	open or close location window
|:move|		:m[ove]		move lines
|:mark|		:ma[rk]		set a mark
|:make|		:mak[e]		execute external command 'makeprg' and parse error messages
|:map|		:map		show or enter a mapping
|:mapclear|	:mapc[lear]	clear all mappings for Normal and Visual mode
|:marks|	:marks		list all marks
|:match|	:mat[ch]	define a match to highlight
|:menu|		:me[nu]		enter a new menu item
|:menutranslate|  :menut[ranslate] add a menu translation item
|:messages|	:mes[sages]	view previously displayed messages
|:mkexrc|	:mk[exrc]	write current mappings and settings to a file
|:mksession|	:mks[ession]	write session info to a file
|:mkspell|	:mksp[ell]	produce .spl spell file
|:mkvimrc|	:mkv[imrc]	write current mappings and settings to a file
|:mkview|	:mkvie[w]	write view of current window to a file
|:mode|		:mod[e]		show or change the screen mode
|:next|		:n[ext]		go to next file in the argument list
|:new|		:new		create a new empty window
|:nmap|		:nm[ap]		like ":map" but for Normal mode
|:nmapclear|	:nmapc[lear]	clear all mappings for Normal mode
|:nmenu|	:nme[nu]	add menu for Normal mode
|:nnoremap|	:nn[oremap]	like ":noremap" but for Normal mode
|:nnoremenu|	:nnoreme[nu]	like ":noremenu" but for Normal mode
|:noautocmd|	:noa[utocmd]	following commands don't trigger autocommands
|:noremap|	:no[remap]	enter a mapping that will not be remapped
|:nohlsearch|	:noh[lsearch]	suspend 'hlsearch' highlighting
|:noreabbrev|	:norea[bbrev]	enter an abbreviation that will not be remapped
|:noremenu|	:noreme[nu]	enter a menu that will not be remapped
|:normal|	:norm[al]	execute Normal mode commands
|:noswapfile|	:nos[wapfile]	following commands don't create a swap file
|:number|	:nu[mber]	print lines with line number
|:nunmap|	:nun[map]	like ":unmap" but for Normal mode
|:nunmenu|	:nunme[nu]	remove menu for Normal mode
|:oldfiles|	:ol[dfiles]	list files that have marks in the |shada| file
|:omap|		:om[ap]		like ":map" but for Operator-pending mode
|:omapclear|	:omapc[lear]	remove all mappings for Operator-pending mode
|:omenu|	:ome[nu]	add menu for Operator-pending mode
|:only|		:on[ly]		close all windows except the current one
|:onoremap|	:ono[remap]	like ":noremap" but for Operator-pending mode
|:onoremenu|	:onoreme[nu]	like ":noremenu" but for Operator-pending mode
|:options|	:opt[ions]	open the options-window
|:ounmap|	:ou[nmap]	like ":unmap" but for Operator-pending mode
|:ounmenu|	:ounme[nu]	remove menu for Operator-pending mode
|:ownsyntax|	:ow[nsyntax]	set new local syntax highlight for this window
|:packadd|	:pa[ckadd]	add a plugin from 'packpath'
|:packloadall|	:packl[oadall]	load all packages under 'packpath'
|:pclose|	:pc[lose]	close preview window
|:pedit|	:ped[it]	edit file in the preview window
|:perl|		:pe[rl]		execute perl command
|:perldo|	:perld[o]	execute perl command for each line
|:perlfile|	:perlf[ile]	execute perl script file
|:print|	:p[rint]	print lines
|:profdel|	:profd[el]	stop profiling a function or script
|:profile|	:prof[ile]	profiling functions and scripts
|:pop|		:po[p]		jump to older entry in tag stack
|:popup|	:popu[p]	popup a menu by name
|:ppop|		:pp[op]		":pop" in preview window
|:preserve|	:pre[serve]	write all text to swap file
|:previous|	:prev[ious]	go to previous file in argument list
|:psearch|	:ps[earch]	like ":ijump" but shows match in preview window
|:ptag|		:pt[ag]		show tag in preview window
|:ptNext|	:ptN[ext]	|:tNext| in preview window
|:ptfirst|	:ptf[irst]	|:trewind| in preview window
|:ptjump|	:ptj[ump]	|:tjump| and show tag in preview window
|:ptlast|	:ptl[ast]	|:tlast| in preview window
|:ptnext|	:ptn[ext]	|:tnext| in preview window
|:ptprevious|	:ptp[revious]	|:tprevious| in preview window
|:ptrewind|	:ptr[ewind]	|:trewind| in preview window
|:ptselect|	:pts[elect]	|:tselect| and show tag in preview window
|:put|		:pu[t]		insert contents of register in the text
|:pwd|		:pw[d]		print current directory
|:py3|		:py3		execute Python 3 command
|:python3|	:python3	same as :py3
|:py3do|	:py3d[o]	execute Python 3 command for each line
|:py3file|	:py3f[ile]	execute Python 3 script file
|:python|	:py[thon]	execute Python command
|:pydo|		:pyd[o]		execute Python command for each line
|:pyfile|	:pyf[ile]	execute Python script file
|:pyx|		:pyx		execute |python_x| command
|:pythonx|	:pythonx	same as :pyx
|:pyxdo|	:pyxd[o]	execute |python_x| command for each line
|:pyxfile|	:pyxf[ile]	execute |python_x| script file
|:read|		:r[ead]		read file into the text
|:recover|	:rec[over]	recover a file from a swap file
|:redo|		:red[o]		redo one undone change
|:redir|	:redi[r]	redirect messages to a file or register
|:redraw|	:redr[aw]	force a redraw of the display
|:redrawstatus|	:redraws[tatus]	force a redraw of the status line(s) and window bar(s)
|:registers|	:reg[isters]	display the contents of registers
|:resize|	:res[ize]	change current window height
|:return|	:retu[rn]	return from a user function
|:rewind|	:rew[ind]	go to the first file in the argument list
|:right|	:ri[ght]	right align text
|:rightbelow|	:rightb[elow]	make split window appear right or below
|:rshada|	:rsh[ada]	read from |shada| file
|:ruby|		:rub[y]		execute Ruby command
|:rubydo|	:rubyd[o]	execute Ruby command for each line
|:rubyfile|	:rubyf[ile]	execute Ruby script file
|:rundo|	:rund[o]	read undo information from a file
|:runtime|	:ru[ntime]	source vim scripts in 'runtimepath'
|:substitute|	:s[ubstitute]	find and replace text
|:sNext|	:sN[ext]	split window and go to previous file in argument list
|:sandbox|	:san[dbox]	execute a command in the sandbox
|:sargument|	:sa[rgument]	split window and go to specific file in argument list
|:sall|		:sal[l]		open a window for each file in argument list
|:saveas|	:sav[eas]	save file under another name.
|:sbuffer|	:sb[uffer]	split window and go to specific file in the buffer list
|:sbNext|	:sbN[ext]	split window and go to previous file in the buffer list
|:sball|	:sba[ll]	open a window for each file in the buffer list
|:sbfirst|	:sbf[irst]	split window and go to first file in the buffer list
|:sblast|	:sbl[ast]	split window and go to last file in buffer list
|:sbmodified|	:sbm[odified]	split window and go to modified file in the buffer list
|:sbnext|	:sbn[ext]	split window and go to next file in the buffer list
|:sbprevious|	:sbp[revious]	split window and go to previous file in the buffer list
|:sbrewind|	:sbr[ewind]	split window and go to first file in the buffer list
|:scriptnames|	:scr[iptnames]	list names of all sourced Vim scripts
|:scriptencoding| :scripte[ncoding]  encoding used in sourced Vim script
|:set|		:se[t]		show or set options
|:setfiletype|	:setf[iletype]	set 'filetype', unless it was set already
|:setglobal|	:setg[lobal]	show global values of options
|:setlocal|	:setl[ocal]	show or set options locally
|:sfind|	:sf[ind]	split current window and edit file in 'path'
|:sfirst|	:sfir[st]	split window and go to first file in the argument list
|:sign|		:sig[n]		manipulate signs
|:silent|	:sil[ent]	run a command silently
|:sleep|	:sl[eep]	do nothing for a few seconds
|:slast|	:sla[st]	split window and go to last file in the argument list
|:smagic|	:sm[agic]	:substitute with 'magic'
|:snext|	:sn[ext]	split window and go to next file in the argument list
|:snomagic|	:sno[magic]	:substitute with 'nomagic'
|:sort|		:sor[t]		sort lines
|:source|	:so[urce]	read Vim or Ex commands from a file
|:spelldump|	:spelld[ump]	split window and fill with all correct words
|:spellgood|	:spe[llgood]	add good word for spelling
|:spellinfo|	:spelli[nfo]	show info about loaded spell files
|:spellrare|	:spellra[re]	add rare word for spelling
|:spellrepall|	:spellr[epall]	replace all bad words like last |z=|
|:spellundo|	:spellu[ndo]	remove good or bad word
|:spellwrong|	:spellw[rong]	add spelling mistake
|:split|	:sp[lit]	split current window
|:sprevious|	:spr[evious]	split window and go to previous file in the argument list
|:srewind|	:sre[wind]	split window and go to first file in the argument list
|:stop|		:st[op]		suspend the editor or escape to a shell
|:stag|		:sta[g]		split window and jump to a tag
|:startinsert|	:star[tinsert]	start Insert mode
|:startgreplace|  :startg[replace] start Virtual Replace mode
|:startreplace|	:startr[eplace]	start Replace mode
|:stopinsert|	:stopi[nsert]	stop Insert mode
|:stjump|	:stj[ump]	do ":tjump" and split window
|:stselect|	:sts[elect]	do ":tselect" and split window
|:sunhide|	:sun[hide]	same as ":unhide"
|:suspend|	:sus[pend]	same as ":stop"
|:sview|	:sv[iew]	split window and edit file read-only
|:swapname|	:sw[apname]	show the name of the current swap file
|:syntax|	:sy[ntax]	syntax highlighting
|:syntime|	:synti[me]	measure syntax highlighting speed
|:syncbind|	:sync[bind]	sync scroll binding
|:t|		:t		same as ":copy"
|:tNext|	:tN[ext]	jump to previous matching tag
|:tag|		:ta[g]		jump to tag
|:tags|		:tags		show the contents of the tag stack
|:terminal|	:te[rminal]	open a terminal buffer
|:tfirst|	:tf[irst]	jump to first matching tag
|:throw|	:th[row]	throw an exception
|:tjump|	:tj[ump]	like ":tselect", but jump directly when there is only one match
|:tlast|	:tl[ast]	jump to last matching tag
|:tlmenu|	:tlm[enu]	add menu for |Terminal-mode|
|:tlnoremenu|	:tln[oremenu]	like ":noremenu" but for |Terminal-mode|
|:tlunmenu|	:tlu[nmenu]	remove menu for |Terminal-mode|
|:tmapclear|	:tmapc[lear]	remove all mappings for |Terminal-mode|
|:tmap|		:tma[p]		like ":map" but for |Terminal-mode|
|:tmenu|	:tm[enu]	define menu tooltip
|:tnext|	:tn[ext]	jump to next matching tag
|:tnoremap|	:tno[remap]	like ":noremap" but for |Terminal-mode|
|:topleft|	:to[pleft]	make split window appear at top or far left
|:tprevious|	:tp[revious]	jump to previous matching tag
|:trewind|	:tr[ewind]	jump to first matching tag
|:try|		:try		execute commands, abort on error or exception
|:tselect|	:ts[elect]	list matching tags and select one
|:tunmap|	:tunma[p]	like ":unmap" but for |Terminal-mode|
|:tunmenu|	:tu[nmenu]	remove menu tooltip
|:undo|		:u[ndo]		undo last change(s)
|:undojoin|	:undoj[oin]	join next change with previous undo block
|:undolist|	:undol[ist]	list leafs of the undo tree
|:unabbreviate|	:una[bbreviate]	remove abbreviation
|:unhide|	:unh[ide]	open a window for each loaded file in the buffer list
|:unlet|	:unl[et]	delete variable
|:unlockvar|	:unlo[ckvar]	unlock variables
|:unmap|	:unm[ap]	remove mapping
|:unmenu|	:unme[nu]	remove menu
|:unsilent|	:uns[ilent]	run a command not silently
|:update|	:up[date]	write buffer if modified
|:vglobal|	:v[global]	execute commands for not matching lines
|:version|	:ve[rsion]	print version number and other info
|:verbose|	:verb[ose]	execute command with 'verbose' set
|:vertical|	:vert[ical]	make following command split vertically
|:vimgrep|	:vim[grep]	search for pattern in files
|:vimgrepadd|	:vimgrepa[dd]	like :vimgrep, but append to current list
|:visual|	:vi[sual]	same as ":edit", but turns off "Ex" mode
|:viusage|	:viu[sage]	overview of Normal mode commands
|:view|		:vie[w]		edit a file read-only
|:vnew|		:vne[w]		create a new empty window, vertically split
|:vsplit|	:vs[plit]	split current window vertically
|:windo|	:windo		execute command in each window
|:write|	:w[rite]	write to a file
|:wNext|	:wN[ext]	write to a file and go to previous file in argument list
|:wall|		:wa[ll]		write all (changed) buffers
|:while|	:wh[ile]	execute loop for as long as condition met
|:winsize|	:wi[nsize]	get or set window size (obsolete)
|:winpos|	:winp[os]	get or set window position
|:wnext|	:wn[ext]	write to a file and go to next file in argument list
|:wprevious|	:wp[revious]	write to a file and go to previous file in argument list
|:wq|		:wq		write to a file and quit window or Vim
|:wqall|	:wqa[ll]	write all changed buffers and quit Vim
|:wshada|	:wsh[ada]	write to ShaDa file
|:wundo|	:wu[ndo]	write undo information to a file
|:xit|		:x[it]		write if buffer changed and close window
|:xall|		:xa[ll]		same as ":wqall"
|:xmapclear|	:xmapc[lear]	remove all mappings for Visual mode
|:xmap|		:xm[ap]		like ":map" but for Visual mode
|:xmenu|	:xme[nu]	add menu for Visual mode
|:xnoremap|	:xn[oremap]	like ":noremap" but for Visual mode
|:xnoremenu|	:xnoreme[nu]	like ":noremenu" but for Visual mode
|:xunmap|	:xu[nmap]	like ":unmap" but for Visual mode
|:xunmenu|	:xunme[nu]	remove menu for Visual mode
|:~|		:~		repeat last ":substitute"







              *motion-count-multiplied*
If the motion includes a count and the operator also had a count before it,
the two counts are multiplied.  For example: "2d3w" deletes six words.
						*operator-doubled*
When doubling the operator it operates on a line.  When using a count, before
or after the first character, that many lines are operated upon.  Thus `3dd`
deletes three lines. A count before and after the first character is
multiplied, thus `2y3y` yanks six lines.

After applying the operator the cursor is mostly left at the start of the text
that was operated upon.  For example, "yfe" doesn't move the cursor, but "yFe"
moves the cursor leftwards to the "e" where the yank started.

						*linewise* *charwise* *characterwise*
The operator either affects whole lines, or the characters between the start
and end position.  Generally, motions that move between lines affect lines
(are linewise), and motions that move within a line affect characters (are
charwise).  However, there are some exceptions.

						*exclusive* *inclusive*
Character motion is either inclusive or exclusive.  When inclusive, the
start and end position of the motion are included in the operation.  When
exclusive, the last character towards the end of the buffer is not included.
Linewise motions always include the start and end position.  Plugins can
check the v:event.inclusive flag of the |TextYankPost| event.

Which motions are linewise, inclusive or exclusive is mentioned with the
command.  There are however, two general exceptions:
1. If the motion is exclusive and the end of the motion is in column 1, the
   end of the motion is moved to the end of the previous line and the motion
   becomes inclusive.  Example: "}" moves to the first line after a paragraph,
   but "d}" will not include that line.
						*exclusive-linewise*
2. If the motion is exclusive, the end of the motion is in column 1 and the
   start of the motion was at or before the first non-blank in the line, the
   motion becomes linewise.  Example: If a paragraph begins with some blanks
   and you do "d}" while standing on the first non-blank, all the lines of
   the paragraph are deleted, including the blanks.  If you do a put now, the
   deleted lines will be inserted below the cursor position.

Note that when the operator is pending (the operator command is typed, but the
motion isn't yet), a special set of mappings can be used.  See |:omap|.

Instead of first giving the operator and then a motion you can use Visual
mode: mark the start of the text with "v", move the cursor to the end of the
text that is to be affected and then hit the operator.  The text between the
start and the cursor position is highlighted, so you can see what text will
be operated upon.  This allows much more freedom, but requires more key
strokes and has limited redo functionality.  See the chapter on Visual mode
|Visual-mode|.

You can use a ":" command for a motion.  For example "d:call FindEnd()".
But this can't be repeated with "." if the command is more than one line.
This can be repeated:  
	d:call search("f")<CR>
This cannot be repeated:  
	d:if 1<CR>
	   call search("f")<CR>
	endif<CR>
Note that when using ":" any motion becomes charwise exclusive.

								*forced-motion*
FORCING A MOTION TO BE LINEWISE, CHARWISE OR BLOCKWISE

When a motion is not of the type you would like to use, you can force another
type by using "v", "V" or CTRL-V just after the operator.
Example:  
	dj
deletes two lines  
	dvj
deletes from the cursor position until the character below the cursor  
	d<C-V>j
deletes the character under the cursor and the character below the cursor.  

Be careful with forcing a linewise movement to be used charwise or blockwise,
the column may not always be defined.

							*o_v*
v		When used after an operator, before the motion command: Force
		the operator to work charwise, also when the motion is
		linewise.  If the motion was linewise, it will become
		|exclusive|.
		If the motion already was charwise, toggle
		inclusive/exclusive.  This can be used to make an exclusive
		motion inclusive and an inclusive motion exclusive.

							*o_V*
V		When used after an operator, before the motion command: Force
		the operator to work linewise, also when the motion is
		charwise.

							*o_CTRL-V*
CTRL-V		When used after an operator, before the motion command: Force
		the operator to work blockwise.  This works like Visual block
		mode selection, with the corners defined by the cursor
		position before and after the motion.

==============================================================================
2. Left-right motions					*left-right-motions*

These commands move the cursor to the specified column in the current line.
They stop at the first column and at the end of the line, except "$", which
may move to one of the next lines.  See 'whichwrap' option to make some of the
commands move across line boundaries.

h		or					*h*
<Left>		or					*<Left>*
<BS>			[count] characters to the left.  |exclusive| motion.
			Note: If you prefer <BS> to delete a character, use
			the mapping:
				:map CTRL-V<BS>		X
			(to enter "CTRL-V<BS>" type the CTRL-V key, followed
			by the <BS> key)

l		or					*l*
<Right>		or					*<Right>* *<Space>*
<Space>			[count] characters to the right.  |exclusive| motion.
			See the 'whichwrap' option for adjusting the behavior
			at end of line

							*0*
0			To the first character of the line.  |exclusive|
			motion.

							*<Home>* *<kHome>*
<Home>			To the first character of the line.  |exclusive|
			motion.  When moving up or down next, stay in same
			TEXT column (if possible).  Most other commands stay
			in the same SCREEN column.  <Home> works like "1|",
			which differs from "0" when the line starts with a
			<Tab>.

							*^*
^			To the first non-blank character of the line.
			|exclusive| motion.  Any count is ignored.

							*$* *<End>* *<kEnd>*
$  or <End>		To the end of the line.  When a count is given also go
			[count - 1] lines downward, or as far is possible.
			|inclusive| motion.  If a count of 2 or larger is
			given and the cursor is on the last line, that is an
			error and the cursor doesn't move.
			In Visual mode the cursor goes to just after the last
			character in the line.
			When 'virtualedit' is active, "$" may move the cursor
			back from past the end of the line to the last
			character in the line.

							*g_*
g_			To the last non-blank character of the line and
			[count - 1] lines downward |inclusive|.

							*g0* *g<Home>*
g0 or g<Home>		When lines wrap ('wrap' on): To the first character of
			the screen line.  |exclusive| motion.  Differs from
			"0" when a line is wider than the screen.
			When lines don't wrap ('wrap' off): To the leftmost
			character of the current line that is on the screen.
			Differs from "0" when the first character of the line
			is not on the screen.

							*g^*
g^			When lines wrap ('wrap' on): To the first non-blank
			character of the screen line.  |exclusive| motion.
			Differs from "^" when a line is wider than the screen.
			When lines don't wrap ('wrap' off): To the leftmost
			non-blank character of the current line that is on the
			screen.  Differs from "^" when the first non-blank
			character of the line is not on the screen.

							*gm*
gm			Like "g0", but half a screenwidth to the right (or as
			much as possible).

							*gM*
gM			Like "g0", but to halfway the text of the line.
			With a count: to this percentage of text in the line.
			Thus "10gM" is near the start of the text and "90gM"
			is near the end of the text.

							*g$* *g<End>*
g$ or g<End>		When lines wrap ('wrap' on): To the last character of
			the screen line and [count - 1] screen lines downward
			|inclusive|.  Differs from "$" when a line is wider
			than the screen.
			When lines don't wrap ('wrap' off): To the rightmost
			character of the current line that is visible on the
			screen.  Differs from "$" when the last character of
			the line is not on the screen or when a count is used.
			Additionally, vertical movements keep the column,
			instead of going to the end of the line.
			When 'virtualedit' is enabled moves to the end of the
			screen line.

							*bar*
|			To screen column [count] in the current line.
			|exclusive| motion.  Ceci n'est pas une pipe.

							*f*
f{char}			To [count]'th occurrence of {char} to the right.  The
			cursor is placed on {char} |inclusive|.
			{char} can be entered as a digraph |digraph-arg|.
			When 'encoding' is set to Unicode, composing
			characters may be used, see |utf-8-char-arg|.
			|:lmap| mappings apply to {char}.  The CTRL-^ command
			in Insert mode can be used to switch this on/off
			|i_CTRL-^|.

							*F*
F{char}			To the [count]'th occurrence of {char} to the left.
			The cursor is placed on {char} |exclusive|.
			{char} can be entered like with the |f| command.

							*t*
t{char}			Till before [count]'th occurrence of {char} to the
			right.  The cursor is placed on the character left of
			{char} |inclusive|.
			{char} can be entered like with the |f| command.

							*T*
T{char}			Till after [count]'th occurrence of {char} to the
			left.  The cursor is placed on the character right of
			{char} |exclusive|.
			{char} can be entered like with the |f| command.

							*;*
;			Repeat latest f, t, F or T [count] times. See |cpo-;|

							*,*
,			Repeat latest f, t, F or T in opposite direction
			[count] times. See also |cpo-;|

==============================================================================
3. Up-down motions					*up-down-motions*

k		or					*k*
<Up>		or					*<Up>* *CTRL-P*
CTRL-P			[count] lines upward |linewise|.

j		or					*j*
<Down>		or					*<Down>*
CTRL-J		or					*CTRL-J*
<NL>		or					*<NL>* *CTRL-N*
CTRL-N			[count] lines downward |linewise|.

gk		or					*gk* *g<Up>*
g<Up>			[count] display lines upward.  |exclusive| motion.
			Differs from 'k' when lines wrap, and when used with
			an operator, because it's not linewise.

gj		or					*gj* *g<Down>*
g<Down>			[count] display lines downward.  |exclusive| motion.
			Differs from 'j' when lines wrap, and when used with
			an operator, because it's not linewise.

							*-*
`-`  <minus>		[count] lines upward, on the first non-blank
			character |linewise|.

`+`		or					*+*
CTRL-M		or					*CTRL-M* *<CR>*
<CR>			[count] lines downward, on the first non-blank
			character |linewise|.

							*_*
_  <underscore>		[count] - 1 lines downward, on the first non-blank
			character |linewise|.

							*G*
G			Goto line [count], default last line, on the first
			non-blank character |linewise|.  If 'startofline' not
			set, keep the same column.
			G is one of the |jump-motions|.

							*<C-End>*
<C-End>			Goto line [count], default last line, on the last
			character |inclusive|.

<C-Home>	or					*gg* *<C-Home>*
gg			Goto line [count], default first line, on the first
			non-blank character |linewise|.  If 'startofline' not
			set, keep the same column.

							*:[range]*
:[range]		Set the cursor on the last line number in [range].
			[range] can also be just one line number, e.g., ":1"
			or ":'m".
			In contrast with |G| this command does not modify the
			|jumplist|.
							*N%*
{count}%		Go to {count} percentage in the file, on the first
			non-blank in the line |linewise|.  To compute the new
			line number this formula is used:
			    ({count} * number-of-lines + 99) / 100
			See also 'startofline' option.

:[range]go[to] [count]					*:go* *:goto* *go*
[count]go		Go to [count] byte in the buffer.  Default [count] is
			one, start of the file.  When giving [range], the
			last number in it used as the byte count.  End-of-line
			characters are counted depending on the current
			'fileformat' setting.
			Also see the |line2byte()| function, and the 'o'
			option in 'statusline'.

These commands move to the specified line.  They stop when reaching the first
or the last line.  The first two commands put the cursor in the same column
(if possible) as it was after the last command that changed the column,
except after the "$" command, then the cursor will be put on the last
character of the line.

==============================================================================
4. Word motions						*word-motions*

<S-Right>	or					*<S-Right>* *w*
w			[count] words forward.  |exclusive| motion.

<C-Right>	or					*<C-Right>* *W*
W			[count] WORDS forward.  |exclusive| motion.

							*e*
e			Forward to the end of word [count] |inclusive|.
			Does not stop in an empty line.

							*E*
E			Forward to the end of WORD [count] |inclusive|.
			Does not stop in an empty line.

<S-Left>	or					*<S-Left>* *b*
b			[count] words backward.  |exclusive| motion.

<C-Left>	or					*<C-Left>* *B*
B			[count] WORDS backward.  |exclusive| motion.

							*ge*
ge			Backward to the end of word [count] |inclusive|.

							*gE*
gE			Backward to the end of WORD [count] |inclusive|.

These commands move over words or WORDS.
							*word*
A word consists of a sequence of letters, digits and underscores, or a
sequence of other non-blank characters, separated with white space (spaces,
tabs, <EOL>).  This can be changed with the 'iskeyword' option.  An empty line
is also considered to be a word.
							*WORD*
A WORD consists of a sequence of non-blank characters, separated with white
space.  An empty line is also considered to be a WORD.

A sequence of folded lines is counted for one word of a single character.
"w" and "W", "e" and "E" move to the start/end of the first word or WORD after
a range of folded lines.  "b" and "B" move to the start of the first word or
WORD before the fold.

Special case: "cw" and "cW" are treated like "ce" and "cE" if the cursor is
on a non-blank.  This is Vi-compatible, see |cpo-_| to change the behavior.

Another special case: When using the "w" motion in combination with an
operator and the last word moved over is at the end of a line, the end of
that word becomes the end of the operated text, not the first word in the
next line.

The original Vi implementation of "e" is buggy.  For example, the "e" command
will stop on the first character of a line if the previous line was empty.
But when you use "2e" this does not happen.  In Vim "ee" and "2e" are the
same, which is more logical.  However, this causes a small incompatibility
between Vi and Vim.

==============================================================================
5. Text object motions					*object-motions*

							*(*
(			[count] |sentence|s backward.  |exclusive| motion.

							*)*
)			[count] |sentence|s forward.  |exclusive| motion.

							*{*
{			[count] |paragraph|s backward.  |exclusive| motion.

							*}*
}			[count] |paragraph|s forward.  |exclusive| motion.

							*]]*
]]			[count] |section|s forward or to the next "{" in the
			first column.  When used after an operator, then also
			stops below a "}" in the first column.  |exclusive|
			Note that |exclusive-linewise| often applies.

							*][*
][			[count] |section|s forward or to the next '}' in the
			first column.  |exclusive|
			Note that |exclusive-linewise| often applies.

							*[[*
[[			[count] |section|s backward or to the previous "{" in
			the first column.  |exclusive|
			Note that |exclusive-linewise| often applies.

							*[]*
[]			[count] |section|s backward or to the previous "}" in
			the first column.  |exclusive|
			Note that |exclusive-linewise| often applies.

These commands move over three kinds of text objects.

							*sentence*
A sentence is defined as ending at a '.', '!' or '?' followed by either the
end of a line, or by a space or tab.  Any number of closing ')', ']', '"'
and ''' characters may appear after the '.', '!' or '?' before the spaces,
tabs or end of line.  A paragraph and section boundary is also a sentence
boundary.
If the 'J' flag is present in 'cpoptions', at least two spaces have to
follow the punctuation mark; <Tab>s are not recognized as white space.
The definition of a sentence cannot be changed.

							*paragraph*
A paragraph begins after each empty line, and also at each of a set of
paragraph macros, specified by the pairs of characters in the 'paragraphs'
option.  The default is "IPLPPPQPP TPHPLIPpLpItpplpipbp", which corresponds to
the macros ".IP", ".LP", etc.  (These are nroff macros, so the dot must be in
the first column).  A section boundary is also a paragraph boundary.
Note that a blank line (only containing white space) is NOT a paragraph
boundary.
Note: this does not include a '{' or '}' in the first column.

							*section*
A section begins after a form-feed (<C-L>) in the first column and at each of
a set of section macros, specified by the pairs of characters in the
'sections' option.  The default is "SHNHH HUnhsh", which defines a section to
start at the nroff macros ".SH", ".NH", ".H", ".HU", ".nh" and ".sh".

The "]]" and "[[" commands stop at the '{' in the first column.  This is
useful to find the start of a function in a C program.  To search for a '}' in
the first column, the end of a C function, use "][" (forward) or "[]"
(backward).  Note that the first character of the command determines the
search direction.

If your '{' or '}' are not in the first column, and you would like to use "[["
and "]]" anyway, try these mappings:  
   :map [[ ?{<CR>w99[{
   :map ][ /}<CR>b99]}
   :map ]] j0[[%/{<CR>
   :map [] k$][%?}<CR>
[type these literally, see |<>|]

==============================================================================
6. Text object selection			*object-select* *text-objects*
						*v_a* *v_i*

This is a series of commands that can only be used while in Visual mode or
after an operator.  The commands that start with "a" select "a"n object
including white space, the commands starting with "i" select an "inner" object
without white space, or just the white space.  Thus the "inner" commands
always select less text than the "a" commands.

Also see `gn` and `gN`, operating on the last search pattern.

							*v_aw* *aw*
aw			"a word", select [count] words (see |word|).
			Leading or trailing white space is included, but not
			counted.
			When used in Visual linewise mode "aw" switches to
			Visual charwise mode.

							*v_iw* *iw*
iw			"inner word", select [count] words (see |word|).
			White space between words is counted too.
			When used in Visual linewise mode "iw" switches to
			Visual charwise mode.

							*v_aW* *aW*
aW			"a WORD", select [count] WORDs (see |WORD|).
			Leading or trailing white space is included, but not
			counted.
			When used in Visual linewise mode "aW" switches to
			Visual charwise mode.

							*v_iW* *iW*
iW			"inner WORD", select [count] WORDs (see |WORD|).
			White space between words is counted too.
			When used in Visual linewise mode "iW" switches to
			Visual charwise mode.

							*v_as* *as*

							*v_ap* *ap*
ap			"a paragraph", select [count] paragraphs (see
			|paragraph|).
			Exception: a blank line (only containing white space)
			is also a paragraph boundary.
			When used in Visual mode it is made linewise.

							*v_ip* *ip*
ip			"inner paragraph", select [count] paragraphs (see
			|paragraph|).
			Exception: a blank line (only containing white space)
			is also a paragraph boundary.
			When used in Visual mode it is made linewise.

a]						*v_a]* *v_a[* *a]* *a[*
a[			"a [] block", select [count] '[' ']' blocks.  This
			goes backwards to the [count] unclosed '[', and finds
			the matching ']'.  The enclosed text is selected,
			including the '[' and ']'.
			When used in Visual mode it is made charwise.

i]						*v_i]* *v_i[* *i]* *i[*
i[			"inner [] block", select [count] '[' ']' blocks.  This
			goes backwards to the [count] unclosed '[', and finds
			the matching ']'.  The enclosed text is selected,
			excluding the '[' and ']'.
			When used in Visual mode it is made charwise.

a)							*v_a)* *a)* *a(*
a(							*vab* *v_ab* *v_a(* *ab*
ab			"a block", select [count] blocks, from "[count] [(" to
			the matching ')', including the '(' and ')' (see
			|[(|).  Does not include white space outside of the
			parenthesis.
			When used in Visual mode it is made charwise.

i)							*v_i)* *i)* *i(*
i(							*vib* *v_ib* *v_i(* *ib*
ib			"inner block", select [count] blocks, from "[count] [("
			to the matching ')', excluding the '(' and ')' (see
			|[(|).  If the cursor is not inside a () block, then
			find the next "(".
			When used in Visual mode it is made charwise.

a>						*v_a>* *v_a<* *a>* *a<*
a<			"a <> block", select [count] <> blocks, from the
			[count]'th unmatched '<' backwards to the matching
			'>', including the '<' and '>'.
			When used in Visual mode it is made charwise.

i>						*v_i>* *v_i<* *i>* *i<*
i<			"inner <> block", select [count] <> blocks, from
			the [count]'th unmatched '<' backwards to the matching
			'>', excluding the '<' and '>'.
			When used in Visual mode it is made charwise.

						*v_at* *at*
at			"a tag block", select [count] tag blocks, from the
			[count]'th unmatched "<aaa>" backwards to the matching
			"</aaa>", including the "<aaa>" and "</aaa>".
			See |tag-blocks| about the details.
			When used in Visual mode it is made charwise.

						*v_it* *it*
it			"inner tag block", select [count] tag blocks, from the
			[count]'th unmatched "<aaa>" backwards to the matching
			"</aaa>", excluding the "<aaa>" and "</aaa>".
			See |tag-blocks| about the details.
			When used in Visual mode it is made charwise.

a}							*v_a}* *a}* *a{*
a{							*v_aB* *v_a{* *aB*
aB			"a Block", select [count] Blocks, from "[count] [{" to
			the matching '}', including the '{' and '}' (see
			|[{|).
			When used in Visual mode it is made charwise.

i}							*v_i}* *i}* *i{*
i{							*v_iB* *v_i{* *iB*
iB			"inner Block", select [count] Blocks, from "[count] [{"
			to the matching '}', excluding the '{' and '}' (see
			|[{|).
			When used in Visual mode it is made charwise.

a"							*v_aquote* *aquote*
a'							*v_a'* *a'*
a`							*v_a`* *a`*
			"a quoted string".  Selects the text from the previous
			quote until the next quote.  The 'quoteescape' option
			is used to skip escaped quotes.
			Only works within one line.
			When the cursor starts on a quote, Vim will figure out
			which quote pairs form a string by searching from the
			start of the line.
			Any trailing white space is included, unless there is
			none, then leading white space is included.
			When used in Visual mode it is made charwise.
			Repeating this object in Visual mode another string is
			included.  A count is currently not used.

i"							*v_iquote* *iquote*
i'							*v_i'* *i'*
i`							*v_i`* *i`*
			Like a", a' and a`, but exclude the quotes and
			repeating won't extend the Visual selection.
			Special case: With a count of 2 the quotes are
			included, but no extra white space as with a"/a'/a`.

When used after an operator:
For non-block objects:
	For the "a" commands: The operator applies to the object and the white
	space after the object.  If there is no white space after the object
	or when the cursor was in the white space before the object, the white
	space before the object is included.
	For the "inner" commands: If the cursor was on the object, the
	operator applies to the object.  If the cursor was on white space, the
	operator applies to the white space.
For a block object:
	The operator applies to the block where the cursor is in, or the block
	on which the cursor is on one of the braces.  For the "inner" commands
	the surrounding braces are excluded.  For the "a" commands, the braces
	are included.

When used in Visual mode:
When start and end of the Visual area are the same (just after typing "v"): 
One object is selected, the same as for using an operator.
When start and end of the Visual area are not the same:
	For non-block objects the area is extended by one object or the white
	space up to the next object, or both for the "a" objects.  The
	direction in which this happens depends on which side of the Visual
	area the cursor is.  For the block objects the block is extended one
	level outwards.
==============================================================================
7. Marks					*mark-motions* *E20* *E78*

Jumping to a mark can be done in two ways:
1. With ` (backtick):	  The cursor is positioned at the specified location
			  and the motion is |exclusive|.
2. With ' (single quote): The cursor is positioned on the first non-blank
			  character in the line of the specified location and
			  the motion is linewise.
						*mark-view*
3. Apart from the above if 'jumpoptions' contains "view", they will also try to
restore the mark view. This is the number of lines between the cursor position
and the window topline (first buffer line displayed in the window) when it was
set.

						*m* *mark* *Mark*
m{a-zA-Z}		Set mark {a-zA-Z} at cursor position (does not move the cursor, this is not a motion command).

						*m'* *m`*
m'  or  m`		Set the previous context mark.  This can be jumped to with the "''" or "``" command (does not move the cursor, this is not a motion command).

						*m<* *m>*
m<  or  m>		Set the |'<| or |'>| mark.  Useful to change what the `gv` command selects.  (does not move the cursor, this is not a motion command).
			        Note that the Visual mode cannot be set, only the start and end position.

						*:ma* *:mark* *E191*
:[range]ma[rk] {a-zA-Z'} Set mark {a-zA-Z'} at last line number in [range], column 0.  Default is cursor line.

						*:k*
:[range]k{a-zA-Z'}	Same as :mark, but the space before the mark name can be omitted.

						*'* *'a* *`* *`a*
'{a-z}  `{a-z}		Jump to the mark {a-z} in the current buffer.

						*'A* *'0* *`A* *`0*
'{A-Z0-9}  `{A-Z0-9}	To the mark {A-Z0-9} in the file where it was set (not a motion command when in another file).

						*g'* *g'a* *g`* *g`a*
g'{mark}  g`{mark}
			Jump to the {mark}, but don't change the jumplist when jumping within the current buffer.  Example:  g`"
 			jumps to the last known position in a file. See also |:keepjumps|.

						*:marks*
:marks			List all the current marks (not a motion command). The |'(|, |')|, |'{| and |'}| marks are not listed. The first column has number zero.
						*E283*
:marks {arg}		List the marks that are mentioned in {arg} (not a motion command).  For example:  :marks aB to list marks 'a' and 'B'.

							*:delm* *:delmarks*
:delm[arks] {marks}	Delete the specified marks.  Marks that can be deleted
			include A-Z and 0-9.  You cannot delete the ' mark.
			They can be specified by giving the list of mark
			names, or with a range, separated with a dash.  Spaces
			are ignored.  Examples:  
			   :delmarks a	      deletes mark a
			   :delmarks a b 1    deletes marks a, b and 1
			   :delmarks Aa       deletes marks A and a
			   :delmarks p-z      deletes marks in the range p to z
			   :delmarks ^.[]     deletes marks ^ . [ ]
			   :delmarks \"	      deletes mark "
 

:delm[arks]!		Delete all marks for the current buffer, but not marks A-Z or 0-9.  Also clear the |changelist|.

A mark is not visible in any way.  It is just a position in the file that is
remembered.  Do not confuse marks with named registers, they are totally
unrelated.

'a - 'z		lowercase marks, valid within one file
'A - 'Z		uppercase marks, also called file marks, valid between files
'0 - '9		numbered marks, set from .shada file

Lowercase marks 'a to 'z are remembered as long as the file remains in the
buffer list.  If you remove the file from the buffer list, all its marks are
lost.  If you delete a line that contains a mark, that mark is erased.

Lowercase marks can be used in combination with operators.  For example: "d't"
deletes the lines from the cursor position to mark 't'.  Hint: Use mark 't' for
Top, 'b' for Bottom, etc..  Lowercase marks are restored when using undo and
redo.

Uppercase marks 'A to 'Z include the file name.  You can use them to jump from
file to file.  You can only use an uppercase mark with an operator if the mark
is in the current file.  The line number of the mark remains correct, even if
you insert/delete lines or edit another file for a moment.  When the 'shada'
option is not empty, uppercase marks are kept in the .shada file.  See
|shada-file-marks|.

Numbered marks '0 to '9 are quite different.  They can not be set directly.
They are only present when using a shada file |shada-file|.  Basically '0
is the location of the cursor when you last exited Vim, '1 the last but one
time, etc.  Use the "r" flag in 'shada' to specify files for which no
Numbered mark should be stored.  See |shada-file-marks|.


							*'[* *`[*
'[  `[			To the first character of the previously changed
			or yanked text.

							*']* *`]*
']  `]			To the last character of the previously changed or
			yanked text.

After executing an operator the Cursor is put at the beginning of the text
that was operated upon.  After a put command ("p" or "P") the cursor is
sometimes placed at the first inserted line and sometimes on the last inserted
character.  The four commands above put the cursor at either end.  Example:
After yanking 10 lines you want to go to the last one of them: "10Y']".  After
inserting several lines with the "p" command you want to jump to the lowest
inserted line: "p']".  This also works for text that has been inserted.

Note: After deleting text, the start and end positions are the same, except
when using blockwise Visual mode.  These commands do not work when no change
was made yet in the current file.

							*'<* *`<*
'<  `<			To the first line or character of the last selected
			Visual area in the current buffer.  For block mode it
			may also be the last character in the first line (to
			be able to define the block).

							*'>* *`>*
'>  `>			To the last line or character of the last selected
			Visual area in the current buffer.  For block mode it
			may also be the first character of the last line (to
			be able to define the block).  Note that 'selection'
			applies, the position may be just after the Visual
			area.

							*''* *``*
''  ``			To the position before the latest jump, or where the
			last "m'" or "m`" command was given.  Not set when the
			|:keepjumps| command modifier was used.
			Also see |restore-position|.

							*'quote* *`quote*
'"  `"			To the cursor position when last exiting the current
			buffer.  Defaults to the first character of the first
			line.  See |last-position-jump| for how to use this
			for each opened file.
			Only one position is remembered per buffer, not one
			for each window.  As long as the buffer is visible in
			a window the position won't be changed.  Mark is also 
			reset when |:wshada| is run.

							*'^* *`^*
'^  `^			To the position where the cursor was the last time
			when Insert mode was stopped.  This is used by the
			|gi| command.  Not set when the |:keepjumps| command
			modifier was used.

							*'.* *`.*
'.  `.			To the position where the last change was made.  The
			position is at or near where the change started.
			Sometimes a command is executed as several changes,
			then the position can be near the end of what the
			command changed.  For example when inserting a word,
			the position will be on the last character.
			To jump to older changes use |g;|.

							*'(* *`(*
'(  `(			To the start of the current sentence, like the |(|
			command.

							*')* *`)*
')  `)			To the end of the current sentence, like the |)|
			command.

							*'{* *`{*
'{  `{			To the start of the current paragraph, like the |{|
			command.

							*'}* *`}*
'}  `}			To the end of the current paragraph, like the |}|
			command.

These commands are not marks themselves, but jump to a mark:

							*]'*
]'			[count] times to next line with a lowercase mark below
			the cursor, on the first non-blank character in the
			line.

							*]`*
]`			[count] times to lowercase mark after the cursor.

							*['*
['			[count] times to previous line with a lowercase mark
			before the cursor, on the first non-blank character in
			the line.

							*[`*
[`			[count] times to lowercase mark before the cursor.


:loc[kmarks] {command}				*:loc* *:lock* *:lockmarks*
			Execute {command} without adjusting marks.  This is
			useful when changing text in a way that the line count
			will be the same when the change has completed.
			WARNING: When the line count does change, marks below
			the change will keep their line number, thus move to
			another text line.
			These items will not be adjusted for deleted/inserted
			lines:
			- lower case letter marks 'a - 'z
			- upper case letter marks 'A - 'Z
			- numbered marks '0 - '9
			- last insert position '^
			- last change position '.
			- last affected text area '[ and ']
			- the Visual area '< and '>
			- line numbers in placed signs
			- line numbers in quickfix positions
			- positions in the |tagstack|
			These items will still be adjusted:
			- previous context mark ''
			- the cursor position
			- the view of a window on a buffer
			- folds
			- diffs

:kee[pmarks] {command}				*:kee* *:keep* *:keepmarks*
			Currently only has effect for the filter command
			|:range!|:
			- When the number of lines after filtering is equal to
			  or larger than before, all marks are kept at the
			  same line number.
			- When the number of lines decreases, the marks in the
			  lines that disappeared are deleted.
			In any case the marks below the filtered text have
			their line numbers adjusted, thus stick to the text,
			as usual.
			When the 'R' flag is missing from 'cpoptions' this has
			the same effect as using ":keepmarks".

							*:keepj* *:keepjumps*
:keepj[umps] {command}
			Moving around in {command} does not change the |''|,
			|'.| and |'^| marks, the |jumplist| or the
			|changelist|.
			Useful when making a change or inserting text
			automatically and the user doesn't want to go to this
			position.  E.g., when updating a "Last change"
			timestamp in the first line:  

				:let lnum = line(".")
				:keepjumps normal gg
				:call SetLastChange()
				:keepjumps exe "normal " .. lnum .. "G"
 
			Note that ":keepjumps" must be used for every command.
			When invoking a function the commands in that function
			can still change the jumplist.  Also, for
			`:keepjumps exe 'command '` the "command" won't keep
			jumps.  Instead use: `:exe 'keepjumps command'`

==============================================================================
8. Jumps					*jump-motions*

A "jump" is a command that normally moves the cursor several lines away.  If
you make the cursor "jump" the position of the cursor before the jump is
remembered.  You can return to that position with the "''" and "``" commands,
unless the line containing that position was changed or deleted.  The
following commands are "jump" commands: "'", "`", "G", "/", "?", "n", "N",
"%", "(", ")", "[[", "]]", "{", "}", ":s", ":tag", "L", "M", "H" and the
commands that start editing a new file. *CTRL-O*
CTRL-O			Go to [count] Older cursor position in jump list
			(not a motion command).

<Tab>		or					*CTRL-I* *<Tab>*
CTRL-I			Go to [count] newer cursor position in jump list
			(not a motion command).

							*:ju* *:jumps*
:ju[mps]		Print the jump list (not a motion command).

							*:cle* *:clearjumps*
:cle[arjumps]		Clear the jump list of the current window.

							*jumplist*
Jumps are remembered in a jump list.  With the CTRL-O and CTRL-I command you
can go to cursor positions before older jumps, and back again.  Thus you can
move up and down the list.  There is a separate jump list for each window.
The maximum number of entries is fixed at 100.

For example, after three jump commands you have this jump list:

    jump line  col file/text  
      3	  1    0 some text  
      2	 70    0 another line  
      1  1154   23 end.  
   >  

The "file/text" column shows the file name, or the text at the jump if it is
in the current file (an indent is removed and a long line is truncated to fit
in the window).

The marker ">" indicates the current position in the jumplist.  It may not be
shown when filtering the |:jumps| command using |:filter|

You are currently in line 1167.  If you then use the CTRL-O command, the
cursor is put in line 1154.  This results in:

    jump line  col file/text  
      2	  1    0 some text  
      1	 70    0 another line  
   >  0  1154   23 end.  
      1  1167    0 foo bar  

The pointer will be set at the last used jump position.  The next CTRL-O
command will use the entry above it, the next CTRL-I command will use the
entry below it.  If the pointer is below the last entry, this indicates that
you did not use a CTRL-I or CTRL-O before.  In this case the CTRL-O command
will cause the cursor position to be added to the jump list, so you can get
back to the position before the CTRL-O.  In this case this is line 1167.

With more CTRL-O commands you will go to lines 70 and 1.  If you use CTRL-I
you can go back to 1154 and 1167 again.  Note that the number in the "jump"
column indicates the count for the CTRL-O or CTRL-I command that takes you to
this position.

If you use a jump command, the current line number is inserted at the end of
the jump list.  If the same line was already in the jump list, it is removed.
The result is that when repeating CTRL-O you will get back to old positions
only once.

When the |:keepjumps| command modifier is used, jumps are not stored in the
jumplist.  Jumps are also not stored in other cases, e.g., in a |:global|
command.  You can explicitly add a jump by setting the ' mark with "m'".  Note
that calling setpos() does not do this.

After the CTRL-O command that got you into line 1154 you could give another
jump command (e.g., "G").  The jump list would then become:

    jump line  col file/text  
      4	  1    0 some text  
      3	 70    0 another line  
      2  1167    0 foo bar  
      1  1154   23 end.  
   >  

The line numbers will be adjusted for deleted and inserted lines.  This fails
if you stop editing a file without writing, like with ":n!".

When you split a window, the jumplist will be copied to the new window.

If you have included the ' item in the 'shada' option the jumplist will be
stored in the ShaDa file and restored when starting Vim.

							*jumplist-stack*
When jumpoptions includes "stack", the jumplist behaves like the history in a
web browser and like the tag stack.  When jumping to a new location from the
middle of the jumplist, the locations after the current position will be
discarded.

This behavior corresponds to the following situation in a web browser.
Navigate to first.com, second.com, third.com, fourth.com and then fifth.com.
Then navigate backwards twice so that third.com is displayed.  At that point,
the history is:
- first.com
- second.com
- third.com <--
- fourth.com
- fifth.com

Finally, navigate to a different webpage, new.com.  The history is
- first.com
- second.com
- third.com
- new.com <--

When the jumpoptions includes "stack", this is the behavior of Nvim as well.
That is, given a jumplist like the following in which CTRL-O has been used to
move back three times to location X

 jump line  col file/text
   2  1260    8 src/nvim/mark.c         <-- location X-2
   1   685    0 src/nvim/option_defs.h  <-- location X-1
>  0   462   36 src/nvim/option_defs.h  <-- location X
   1   479   39 src/nvim/option_defs.h
   2   213    2 src/nvim/mark.c
   3   181    0 src/nvim/mark.c

jumping to (new) location Y results in the locations after the current
locations being removed:

 jump line  col file/text
   3  1260    8 src/nvim/mark.c
   2   685    0 src/nvim/option_defs.h
   1   462   36 src/nvim/option_defs.h  <-- location X
> 

Then, when yet another location Z is jumped to, the new location Y appears
directly after location X in the jumplist and location X remains in the same
position relative to the locations (X-1, X-2, etc., ...) that had been before it
prior to the original jump from X to Y:

 jump line  col file/text
   4  1260    8 src/nvim/mark.c         <-- location X-2
   3   685    0 src/nvim/option_defs.h  <-- location X-1
   2   462   36 src/nvim/option_defs.h  <-- location X
   1   100    0 src/nvim/option_defs.h  <-- location Y
> 

CHANGE LIST JUMPS			*changelist* *change-list-jumps* *E664*

When making a change the cursor position is remembered.  One position is
remembered for every change that can be undone, unless it is close to a
previous change.  Two commands can be used to jump to positions of changes,
also those that have been undone:

							*g;* *E662*
g;			Go to [count] older position in change list.
			If [count] is larger than the number of older change
			positions go to the oldest change.
			If there is no older change an error message is given.
			(not a motion command)

							*g,* *E663*
g,			Go to [count] newer position in change list.
			Just like |g;| but in the opposite direction.
			(not a motion command)

When using a count you jump as far back or forward as possible.  Thus you can
use "999g;" to go to the first change for which the position is still
remembered.  The number of entries in the change list is fixed and is the same
as for the |jumplist|.

When two undo-able changes are in the same line and at a column position less
than 'textwidth' apart only the last one is remembered.  This avoids that a
sequence of small changes in a line, for example "xxxxx", adds many positions
to the change list.  When 'textwidth' is zero 'wrapmargin' is used.  When that
also isn't set a fixed number of 79 is used.  Detail: For the computations
bytes are used, not characters, to avoid a speed penalty (this only matters
for multibyte encodings).

Note that when text has been inserted or deleted the cursor position might be
a bit different from the position of the change.  Especially when lines have
been deleted.

When the `:keepjumps` command modifier is used the position of a change is not
remembered.

							*:changes*
:changes		Print the change list.  A ">" character indicates the
			current position.  Just after a change it is below the
			newest entry, indicating that `g;` takes you to the
			newest entry position.  The first column indicates the
			count needed to take you to this position.  Example:

				change line  col text  
				    3     9    8 bla bla bla
				    2    11   57 foo is a bar
				    1    14   54 the latest changed line
				>

			The `3g;` command takes you to line 9.  Then the
			output of `:changes` is:

				change line  col text  
				>   0     9    8 bla bla bla
				    1    11   57 foo is a bar
				    2    14   54 the latest changed line

			Now you can use "g," to go to line 11 and "2g," to go
			to line 14.

==============================================================================
9. Various motions				*various-motions*

							*%*
%			Find the next item in this line after or under the
			cursor and jump to its match. |inclusive| motion.
			Items can be:
			([{}])		parenthesis or (curly/square) brackets
					(this can be changed with the
					'matchpairs' option)
			/* */		start or end of C-style comment
			#if, #ifdef, #else, #elif, #endif
					C preprocessor conditionals (when the
					cursor is on the # or no ([{
					is following)
			For other items the matchit plugin can be used, see
			|matchit|.  This plugin also helps to skip matches in
			comments.

			When 'cpoptions' contains "M" |cpo-M| backslashes
			before parens and braces are ignored.  Without "M" the
			number of backslashes matters: an even number doesn't
			match with an odd number.  Thus in "( \) )" and "\( (
			\)" the first and last parenthesis match.

			When the '%' character is not present in 'cpoptions'
			|cpo-%|, parens and braces inside double quotes are
			ignored, unless the number of parens/braces in a line
			is uneven and this line and the previous one does not
			end in a backslash.  '(', '{', '[', ']', '}' and ')'
			are also ignored (parens and braces inside single
			quotes).  Note that this works fine for C, but not for
			Perl, where single quotes are used for strings.

			Nothing special is done for matches in comments.  You
			can either use the |matchit| plugin or put quotes around
			matches.

			No count is allowed, {count}% jumps to a line {count}
			percentage down the file |N%|.  Using '%' on
			#if/#else/#endif makes the movement linewise.

						*[(*
[(			Go to [count] previous unmatched '('.
			|exclusive| motion.

						*[{*
[{			Go to [count] previous unmatched '{'.
			|exclusive| motion.

						*])*
])			Go to [count] next unmatched ')'.
			|exclusive| motion.

						*]}*
]}			Go to [count] next unmatched '}'.
			|exclusive| motion.

The above four commands can be used to go to the start or end of the current
code block.  It is like doing "%" on the '(', ')', '{' or '}' at the other
end of the code block, but you can do this from anywhere in the code block.
Very useful for C programs.  Example: When standing on "case x:", "[{" will
bring you back to the switch statement.

						*]m*
]m			Go to [count] next start of a method (for Java or
			similar structured language).  When not before the
			start of a method, jump to the start or end of the
			class.  When no '{' is found after the cursor, this is
			an error.  |exclusive| motion.
						*]M*
]M			Go to [count] next end of a method (for Java or
			similar structured language).  When not before the end
			of a method, jump to the start or end of the class.
			When no '}' is found after the cursor, this is an
			error. |exclusive| motion.
						*[m*
[m			Go to [count] previous start of a method (for Java or
			similar structured language).  When not after the
			start of a method, jump to the start or end of the
			class.  When no '{' is found before the cursor this is
			an error. |exclusive| motion.
						*[M*
[M			Go to [count] previous end of a method (for Java or
			similar structured language).  When not after the
			end of a method, jump to the start or end of the
			class.  When no '}' is found before the cursor this is
			an error. |exclusive| motion.

The above two commands assume that the file contains a class with methods.
The class definition is surrounded in '{' and '}'.  Each method in the class
is also surrounded with '{' and '}'.  This applies to the Java language.  The
file looks like this:  

	// comment
	class foo {
		int method_one() {
			body_one();
		}
		int method_two() {
			body_two();
		}
	}

[To try this out copy the text and put it in a new buffer, the help text above
confuses the jump commands]

Starting with the cursor on "body_two()", using "[m" will jump to the '{' at
the start of "method_two()" (obviously this is much more useful when the
method is long!).  Using "2[m" will jump to the start of "method_one()".
Using "3[m" will jump to the start of the class.
